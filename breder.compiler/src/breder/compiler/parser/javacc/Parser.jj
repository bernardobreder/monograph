options{  JDK_VERSION = "1.5";  STATIC = false;  CACHE_TOKENS = true;  ERROR_REPORTING = true;  JAVA_UNICODE_ESCAPE = true;  DEBUG_PARSER = false;  DEBUG_LOOKAHEAD = false;  DEBUG_TOKEN_MANAGER = false;  COMMON_TOKEN_ACTION = true;}PARSER_BEGIN(Parser)package breder.compiler.parser.javacc;import java.util.*;import java.io.*;import breder.compiler.node.standart.*;import breder.compiler.node.*;import breder.compiler.node.comment.*;import breder.compiler.node.command.*;import breder.compiler.node.lvalue.*;import breder.compiler.node.rvalue.*;import breder.compiler.compiler.*;import breder.compiler.compiler.Compiler;import breder.compiler.util.*;public class Parser{  public AbstractCompiler compiler;  public BSource s;  public BClass cl;  public BEnum e;  public BMethod m;  public BType tp = null;  public Token t = null;  public Block b = null;  public BParam p = null;  public ICommand c = null;  public Declare d = null;  public BAccess a = null;  public List < Token > tokens = new LightArrayList < Token > ();  public Parser(AbstractCompiler compiler, String classname, InputStream input)  {    this (input);    this.compiler = compiler;    this.s = new BSource(compiler, classname);    this.cl = new BClass(s);  }}PARSER_END(Parser)SKIP :{  " "| "\r"| "\t"| "\n"| "\f"}/* COMMENTS */TOKEN_MGR_DECLS :{  private final List < Comment > comments = new ArrayList < Comment > ();  private final Stack < JavadocComment > javadocStack = new Stack < JavadocComment > ();  private JavadocComment lastJavadoc;  void pushJavadoc()  {    javadocStack.push(lastJavadoc);  }  JavadocComment popJavadoc()  {    return javadocStack.pop();  }  List < Comment > getComments()  {    return comments;  }  void clearComments()  {    comments.clear();    javadocStack.clear();    lastJavadoc = null;  }  private void CommonTokenAction(Token token)  {    lastJavadoc = null;    if (token.specialToken != null)    {      Token special = token.specialToken;      if (special.kind == JAVA_DOC_COMMENT)      {        lastJavadoc = new JavadocComment(special.beginLine, special.beginColumn, special.endLine, special.endColumn, special.image.substring(3, special.image.length() - 2));        comments.add(lastJavadoc);      }      else if (special.kind == SINGLE_LINE_COMMENT)      {        LineComment comment = new LineComment(special.beginLine, special.beginColumn, special.endLine, special.endColumn, special.image.substring(2));        comments.add(comment);      }      else if (special.kind == MULTI_LINE_COMMENT)      {        BlockComment comment = new BlockComment(special.beginLine, special.beginColumn, special.endLine, special.endColumn, special.image.substring(2, special.image.length() - 2));        comments.add(comment);      }    }  }}SPECIAL_TOKEN :{  < SINGLE_LINE_COMMENT :    "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    )? >}MORE :{  < "/**" ~[ "/" ] >  {    input_stream.backup(1);  }  : IN_JAVA_DOC_COMMENT| < "/*" > : IN_MULTI_LINE_COMMENT}< IN_JAVA_DOC_COMMENT >SPECIAL_TOKEN :{  < JAVA_DOC_COMMENT : "*/" > : DEFAULT}< IN_MULTI_LINE_COMMENT >SPECIAL_TOKEN :{  < MULTI_LINE_COMMENT : "*/" > : DEFAULT}< IN_JAVA_DOC_COMMENT, IN_MULTI_LINE_COMMENT >MORE :{  < ~[ ] >}TOKEN :{  < STRING :    "\""    (      (~[ "\"", "\\", "\n", "\r" ])    |      (        "\\"        (          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]        | [ "0"-"7" ] ([ "0"-"7" ])?        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]        )      )    )*    "\"" >| < BOOLEAN :    "true"  | "false" >}TOKEN : /* WORD KEY */{  < PACKAGE : "package" >| < CLASS : "class" >| < ENUM : "enum" >| < INTERFACE : "interface" >| < IMPORT : "import" >| < FINAL : "final" >| < VOID : "void" >| < STATIC : "static" >| < BREAK : "break" >| < CONTINUE : "continue" >| < NATIVE : "native" >| < ABSTRACT : "abstract" >| < NOTNULL : "notnull" >| < IF : "if" >| < WHILE : "while" >| < FOR : "for" >| < TO : "to" >| < TRY : "try" >| < CATCH : "catch" >| < NEW : "new" >| < RETURN : "return" >| < ELSEIF : "elseif" >| < ELSE : "else" >| < THIS : "this" >| < SUPER : "super" >| < EXTENDS : "extends" >| < IMPLEMENTS : "implements" >| < PUBLIC : "public" >| < PROTECTED : "protected" >| < PRIVATE : "private" >| < OR : "or" >| < AND : "and" >| < NULL : "null" >| < REPEAT : "repeat" >| < THROW : "throw" >| < THROWS : "throws" >| < PROPERTY : "property" >}TOKEN : /* OPERATORS */{  < SUM : "+" >| < SUB : "-" >| < MUL : "*" >| < DIV : "/" >| < LPARAM : "(" >| < RPARAM : ")" >| < LBLOCK : "{" >| < RBLOCK : "}" >| < LARRAY : "[" >| < RARRAY : "]" >| < EQUAL : "=" >| < DOT : "." >| < NOT : "!" >| < HIGH : ">" >| < LOW : "<" >| < SEMICOMMA : ";" >| < COMMA : "," >}TOKEN :{  < CONSTANT :    (< ZDIGIT >)+    (      < DOT > (< ZDIGIT >)+    )? >| < NATURAL : (< ZDIGIT >)+ >| < ID :    < LETTER >    (      < LETTER >    | < ZDIGIT >    )* >| < #DIGIT : [ "1"-"9" ] >| < #ZDIGIT : [ "0"-"9" ] >| < #LETTER :    [ "a"-"z" ]  | [ "A"-"Z" ] >}BSource init() :{  Token t;}{  (    < PACKAGE > t = ids()    {      s.setPackageToken(t);    }    < SEMICOMMA >  )?  (    t = importDef()    {      s.addImport(t);    }  )*  (    LOOKAHEAD(access() (< ABSTRACT >  | < FINAL >)* < CLASS >)    classDef()  | interfaceDef()  )  {    return s;  }}void classDef() :{}{  < PUBLIC >  {    cl.setAccess(BAccess.PUBLIC);  }  (    < ABSTRACT >    {      cl.setAbstract(true);    }  | < FINAL >    {      cl.setFinal(true);    }  )*  < CLASS > t = < ID >  {    cl.setName(t);    s.setStruct(cl);  }  (    < LOW >    (      //  <DOT>
      //  <DOT>
      //  <DOT>      //|		
      t = < ID >      (        tp = typeDef()      )?      {        cl.addGeneric(t, tp);      }      (        < COMMA > t = < ID >        (          tp = typeDef()        )?        {          cl.addGeneric(t, tp);        }      )*    )    < HIGH >  )?  (    < EXTENDS > tp = typeDef()    {      cl.addExtends(tp);    }    (      < COMMA > tp = typeDef()      {        cl.addExtends(tp);      }    )*  )?  (    < IMPLEMENTS > tp = typeDef()    {      cl.addImplements(tp);    }    (      < COMMA > tp = typeDef()      {        cl.addImplements(tp);      }    )*  )?  < LBLOCK >  (    LOOKAHEAD(access() (< STATIC >)? < PROPERTY >)    propertyDef()  | LOOKAHEAD(access() (< STATIC >)? (< NOTNULL >)? typeDef() (< DOT > typeDef())* < ID > < SEMICOMMA >)    fieldDef()  | LOOKAHEAD(access() (< NATIVE >)? < ID > < LPARAM >)    constructorDef(cl)  | methodDef(cl)  )*  < RBLOCK >}void enumDef() :{}{  < PUBLIC >  {    e.setAccess(BAccess.PUBLIC);  }  < ENUM > t = < ID >  {    e.setName(t);    s.setStruct(cl);  }  < LBLOCK >  (    < ID > < LPARAM > < RPARAM >    (      < LBLOCK >      (        LOOKAHEAD(access() (< STATIC >)? < PROPERTY >)        propertyDef()      | LOOKAHEAD(access() (< STATIC >)? < ID > (< DOT > < ID >)* < ID > < SEMICOMMA >)        fieldDef()      | methodDef(cl)      )*      < RBLOCK >    | < SEMICOMMA >    )  )  < RBLOCK >}void interfaceDef() :{  BInterface i = new BInterface(s);}{  < PUBLIC >  {    i.setAccess(BAccess.PUBLIC);  }  < INTERFACE > t = < ID >  {    i.setName(t);  }  (    < LOW > t = < ID >    (      tp = typeDef()    )?    {      i.addGeneric(t, tp);    }    (      < COMMA > t = < ID >      (        tp = typeDef()      )?      {        i.addGeneric(t, tp);      }    )*    < HIGH >  )?  (    < EXTENDS > tp = typeDef()    {      i.addExtends(tp);    }    (      < COMMA > tp = typeDef()      {        i.addExtends(tp);      }    )*  )?  < LBLOCK >  (    LOOKAHEAD(< PUBLIC > < ID > < LPARAM >)    constructorInterfaceDef(i)  | methodInterfaceDef(i)  )*  < RBLOCK >}void propertyDef() :{  BProperty field = new BProperty();  Token nnt = null;}{  a = access()  {    field.setAccess(a);  }  (    < STATIC >    {      field.setStatic(true);    }    {      compiler.addStaticField(field);    }  )?  < PROPERTY > (nnt = < NOTNULL >)? tp = typeDef()  {    tp.setNotNull(nnt != null);  }  {    field.setType(tp);  }  t = < ID >  {    field.setName(t);  }  < SEMICOMMA >  {    cl.addField(field);  }}void fieldDef() :{  BField field = new BField();  Token nnt = null;}{  a = access()  {    field.setAccess(a);  }  (    < STATIC >    {      field.setStatic(true);    }    {      compiler.addStaticField(field);    }  )?  (nnt = < NOTNULL >)? tp = typeDef()  {    tp.setNotNull(nnt != null);  }  {    field.setType(tp);  }  t = < ID >  {    field.setName(t);  }  < SEMICOMMA >  {    cl.addField(field);  }}void methodDef(BStruct s) :{  BParam p;  m = new BMethod(s);  Token nnt = null;  Token rt = null;}{  a = access()  {    m.setAccess(a);  }  (    < STATIC >    {      m.setStatic(true);    }  | < NATIVE >    {      m.setNative(true);    }  | < ABSTRACT >    {      m.setAbstract(true);    }  | < FINAL >    {      m.setFinal(true);    }  )*  (    LOOKAHEAD((< NOTNULL >)? < THIS >)    (nnt = < NOTNULL >)? rt = < THIS >    {      m.getReturns().add(new BThisType(rt, nnt));    }  | < VOID >  | (nnt = < NOTNULL >)? tp = typeDef()    {      tp.setNotNull(nnt != null);    }    {      m.getReturns().add(tp);    }    (      < COMMA > (nnt = < NOTNULL >)? tp = typeDef()      {        tp.setNotNull(nnt != null);      }      {        m.getReturns().add(tp);      }    )*  )  t = < ID >  {    m.setName(t);  }  < LPARAM >  (    p = paramDef()    {      m.getParams().add(p);    }    (      < COMMA > p = paramDef()      {        m.getParams().add(p);      }    )*  )?  < RPARAM >  (    < THROWS > tp = typeDef()    {      m.addThrows(tp);    }    (      < COMMA > tp = typeDef()      {        m.addThrows(tp);      }    )*  )?  (    LOOKAHEAD({ !m.isNative() && !m.isAbstract() })    b = blockDef()    {      m.setBlock(b);    }  | < SEMICOMMA >  )  {    cl.addMethod(m);  }}void constructorInterfaceDef(BStruct s) :{  BParam p;  m = new BConstructor(s);  Token nnt = null;}{  < PUBLIC >  {    m.setAccess(BAccess.PUBLIC);  }  t = < ID >  {    m.setName(t);  }  < LPARAM >  (    p = paramDef()    {      m.getParams().add(p);    }    (      < COMMA > p = paramDef()      {        m.getParams().add(p);      }    )*  )?  < RPARAM >  (    < THROWS > tp = typeDef()    {      m.addThrows(tp);    }    (      < COMMA > tp = typeDef()      {        m.addThrows(tp);      }    )*  )?  < SEMICOMMA >  {    s.addMethod(m);  }}void methodInterfaceDef(BStruct s) :{  BParam p;  m = new BMethod(s);  Token nnt = null;  Token rt = null;}{  < PUBLIC >  {    m.setAccess(BAccess.PUBLIC);  }  (    LOOKAHEAD((< NOTNULL >)? < THIS >)    (nnt = < NOTNULL >)? rt = < THIS >    {      m.getReturns().add(new BThisType(rt, nnt));    }  | rt = < VOID >  | (nnt = < NOTNULL >)? tp = typeDef()    {      tp.setNotNull(nnt != null);    }    {      m.getReturns().add(tp);    }    (      < COMMA > (nnt = < NOTNULL >)? tp = typeDef()      {        tp.setNotNull(nnt != null);      }      {        m.getReturns().add(tp);      }    )*  )  t = < ID >  {    m.setName(t);  }  < LPARAM >  (    p = paramDef()    {      m.getParams().add(p);    }    (      < COMMA > p = paramDef()      {        m.getParams().add(p);      }    )*  )?  < RPARAM >  (    < THROWS > tp = typeDef()    {      m.addThrows(tp);    }    (      < COMMA > tp = typeDef()      {        m.addThrows(tp);      }    )*  )?  < SEMICOMMA >  {    s.addMethod(m);  }}void constructorDef(BStruct s) :{  m = new BConstructor(s);}{  a = access()  {    m.setAccess(a);  }  (    < NATIVE >    {      m.setNative(true);    }  )*  t = < ID >  {    m.setName(t);  }  < LPARAM >  (    paramsDef    (      m.getParams()    )  )?  < RPARAM >  (    < THROWS > tp = typeDef()    {      m.addThrows(tp);    }    (      < COMMA > tp = typeDef()      {        m.addThrows(tp);      }    )*  )?  //////////////////////////////////////////////////////////////////////  // Falta o Throws ////////////////////////////////////////////////////  //////////////////////////////////////////////////////////////////////  (    LOOKAHEAD({ !m.isNative() })    b = blockDef()    {      m.setBlock(b);    }  | < SEMICOMMA >  )  {    cl.addMethod(m);  }}void paramsDef(List < BParam > ps) :{}{  p = paramDef()  {    ps.add(p);  }  (    < COMMA > p = paramDef()    {      ps.add(p);    }  )*}BParam paramDef() :{  Token t, nnt = null;  p = new BParam();}{  (nnt = < NOTNULL >)? tp = typeDef()  {    tp.setNotNull(nnt != null);  }  {    p.setType(tp);  }  t = < ID >  {    p.setName(t);  }  {    return p;  }}BType typeDef() :{  Token t, nnt = null;  BType tp1, tp2;}{  t = ids()  {    tp1 = new BType(t);  }  (    < LOW > tp2 = typeDef()    {      tp1.addGeneric(tp2);    }    (      < COMMA > tp2 = typeDef()      {        tp1.addGeneric(tp2);      }    )*    < HIGH >  )?  {    return tp1;  }}Block blockDef() :{  Block b = new Block();  Token t;}{  {    m.pushBlock(b);  }  (    < LBLOCK >    (      c = commandDef()      {        b.getCommands().add(c);      }    )*    < RBLOCK >  )  {    m.popBlock();  }  {    return b;  }}ICommand commandDef() :{}{  (    LOOKAHEAD(typeDef() < ID > (< COMMA >  | < EQUAL >  | < SEMICOMMA >))    c = declareDef() < SEMICOMMA >  | LOOKAHEAD(lvalue() (< COMMA > lvalue())* (< SUM >  | < SUB >  | < MUL >  | < DIV >)? < EQUAL >)    c = assignLDef() < SEMICOMMA >  | c = ifDef()  | c = whileDef()  | c = repeatDef()  | c = forDef()  | c = tryDef()  | c = throwDef() < SEMICOMMA >  | c = returnDef() < SEMICOMMA >  | LOOKAHEAD(< SUPER > < LPARAM >)    c = superDef() < SEMICOMMA >  | c = breakDef() < SEMICOMMA >  | c = continueDef() < SEMICOMMA >  | c = blockDef()  | c = expDef() < SEMICOMMA >  )  {    return c;  }}Declare declareDef() :{  Declare c = new Declare();  VariableDeclare vd;}{  p = paramDef()  {    vd = new VariableDeclare(p.getType(), p.getName());    c.addDeclare(vd);    this.m.addDeclare(vd);  }  (    < COMMA > p = paramDef()    {      vd = new VariableDeclare(p.getType(), p.getName());    }    {      c.addDeclare(vd);    }    {      this.m.addDeclare(vd);    }  )*  (    t = < EQUAL >    {      c.setEqualToken(t);    }    rvalues    (      c.getValues()    )  )?  {    return c;  }}Assign assignLDef() :{  Assign c = new Assign();  ILValue l1;}{  l1 = lvalue()  {    c.getLValues().add(l1);  }  (    < COMMA > l1 = lvalue()    {      c.getLValues().add(l1);    }  )*  (    < SUM >    {      c.setType(Assign.AssignType.SUM);    }  | < SUB >    {      c.setType(Assign.AssignType.SUB);    }  | < MUL >    {      c.setType(Assign.AssignType.MUL);    }  | < DIV >    {      c.setType(Assign.AssignType.DIV);    }  )?  (    t = < EQUAL >    {      c.setToken(t);    }    rvalues    (      c.getRValues()    )  )  {    return c;  }}RAssign assignRDef() :{  RAssign c = new RAssign();  ILValue l1;}{  l1 = lvalue()  {    c.getLValues().add(l1);  }  (    < COMMA > l1 = lvalue()    {      c.getLValues().add(l1);    }  )*  (    < SUM >    {      c.setType(Assign.AssignType.SUM);    }  | < SUB >    {      c.setType(Assign.AssignType.SUB);    }  | < MUL >    {      c.setType(Assign.AssignType.MUL);    }  | < DIV >    {      c.setType(Assign.AssignType.DIV);    }  )?  (    t = < EQUAL >    {      c.setToken(t);    }    rvalues    (      c.getRValues()    )  )  {    return c;  }}If ifDef() :{  If c = new If();  IRValue r1;}{  < IF > < LPARAM > r1 = rvalue() < RPARAM >  {    c.setCondition(r1);  }  b = blockDef()  {    c.setTrueBlock(b);  }  (    < ELSEIF > < LPARAM > r1 = rvalue() < RPARAM >    {      c.getOtherConditions().add(r1);    }    b = blockDef()    {      c.getOtherBlocks().add(b);    }  )*  (    < ELSE > b = blockDef()    {      c.setFalseBlock(b);    }  )?  {    return c;  }}While whileDef() :{  While c = new While();  IRValue r1;}{  < WHILE > < LPARAM > r1 = rvalue() < RPARAM >  {    c.setCondition(r1);  }  b = blockDef()  {    c.setBlock(b);  }  {    return c;  }}Throw throwDef() :{  Throw c = new Throw();  IRValue r1;}{  < THROW > r1 = rvalue()  {    c.setValue(r1);  }  {    return c;  }}Break breakDef() :{  Token t;}{  t = < BREAK >  {    return new Break(t);  }}Continue continueDef() :{  Token t;}{  t = < CONTINUE >  {    return new Continue(t);  }}Repeat repeatDef() :{  Repeat c = new Repeat();  IRValue r1;}{  < REPEAT > b = blockDef()  {    c.setBlock(b);  }  // Retirar o < Semicomma >  < WHILE > r1 = < LPARAM > rvalue() < RPARAM > < SEMICOMMA >  {    c.setCondition(r1);  }  {    return c;  }}For forDef() :{  For c = new For();  Block b = new Block();  IRValue r1;  ICommand cmd;  Token t;}{  t = < FOR >  {    c.setToken(t);    m.pushBlock(b);  }  < LPARAM >  (    d = declareDef()    {      c.setDeclare(d);    }  )?  < SEMICOMMA >  (    r1 = rvalue()    {      c.setCondition(r1);    }  )?  < SEMICOMMA >  (    cmd = assignLDef()    {      c.setIterator(cmd);    }  )?  < RPARAM > < LBLOCK >  (    cmd = commandDef()    {      b.getCommands().add(cmd);    }  )*  < RBLOCK >  {    m.popBlock();  }  {    c.setBlock(b);  }  {    return c;  }}Try tryDef() :{  Token t;  Try c = new Try();  Block b;  ICommand cmd;  VariableDeclare vd;}{  t = < TRY > b = blockDef()  {    c.setTryToken(t);    c.setBlock(b);  }  (    < CATCH > < LPARAM > p = paramDef() < RPARAM >    {      b = new Block();    }    {      m.pushBlock(b);    }    {      vd = new VariableDeclare(p.getType(), p.getName());    }    {      c.getCatchs().add(vd);    }    {      this.m.addDeclare(vd);    }    < LBLOCK >    (      cmd = commandDef()      {        b.getCommands().add(cmd);      }    )*    < RBLOCK >    {      m.popBlock();    }    {      c.getBlocks().add(b);    }  )*  {    return c;  }}Return returnDef() :{  Return c = new Return();  Token t;}{  t = < RETURN >  (    rvalues    (      c.getValues()    )  )?  {    c.setReturnToken(t);  }  {    return c;  }}Super superDef() :{  Super c = new Super();  Token t;}{  t = < SUPER >  {    c.setSuperToken(t);  }  < LPARAM >  {    c.nextParams();  }  (    rvalues    (      c.getParams()    )  )?  (    < SEMICOMMA >    {      c.nextParams();    }    (      rvalues      (        c.getParams()      )    )?  )*  < RPARAM >  {    return c;  }}Expression expDef() :{  IRValue r1;}{  r1 = rvalue()  {    return new Expression(r1);  }}ILValue lvalue() :{  ILValue l1;}{  (    l1 = lidentify()  | l1 = lthis()  )  {    return l1;  }}ILValue lidentify() :{  ILValue l1;}{  (    LOOKAHEAD(< ID > < DOT >)    t = < ID >    {      l1 = new LIdentify(t);    }  | t = < ID >    {      l1 = new LSetIdentify(t);    }  )  (    < DOT > t = < ID >    {      l1 = new LSetField(l1, t);    }  )?  {    return l1;  }}ILValue lthis() :{  ILValue l1;}{  t = < THIS >  {    l1 = new LThis(t);  }  < DOT > t = < ID >  {    l1 = new LSetField(l1, t);  }  {    return l1;  }}void rvalues(List < IRValue > ls) :{  ILValue l1;  IRValue r1;}{  r1 = rvalue()  {    ls.add(r1);  }  (    LOOKAHEAD(< COMMA >)    < COMMA > r1 = rvalue()    {      ls.add(r1);    }  )*}IRValue rvalue() :{  IRValue r1;}{  r1 = ternary()  {    return r1;  }}IRValue ternary() :{  IRValue r1;}{  r1 = or()  {    return r1;  }}IRValue or() :{  IRValue r1, r2;}{  r1 = equal()  (    t = < OR > r2 = equal()    {      r1 = new Or(r1, r2, t);    }  | t = < AND > r2 = equal()    {      r1 = new And(r1, r2, t);    }  )*  {    return r1;  }}IRValue equal() :{  IRValue l, r;  Token t;}{  l = sum()  (    LOOKAHEAD(< EQUAL > < EQUAL >)    t = < EQUAL > t = < EQUAL > r = sum()    {      l = new Equal(l, r, t);    }  | LOOKAHEAD(< NOT > < EQUAL >)    t = < NOT > t = < EQUAL > r = sum()    {      l = new NotEqual(l, r, t);    }  | LOOKAHEAD(< HIGH > < EQUAL >)    t = < HIGH > t = < EQUAL > r = sum()    {      l = new HighEqual(l, r, t);    }  | LOOKAHEAD(< HIGH >)    t = < HIGH > r = sum()    {      l = new High(l, r, t);    }  | LOOKAHEAD(< LOW > < EQUAL >)    t = < LOW > t = < EQUAL > r = sum()    {      l = new LowEqual(l, r, t);    }  | LOOKAHEAD(< LOW >)    t = < LOW > r = sum()    {      l = new Low(l, r, t);    }  )*  {    return l;  }}IRValue sum() :{  IRValue l, r;  Token t;}{  l = mul()  (    t = < SUM > r = mul()    {      l = new Sum(l, r, t);    }  | t = < SUB > r = mul()    {      l = new Sub(l, r, t);    }  )*  {    return l;  }}IRValue mul() :{  IRValue l, r;  Token t;}{  l = unary()  (    t = < MUL > r = unary()    {      l = new Mul(l, r, t);    }  | t = < DIV > r = unary()    {      l = new Div(l, r, t);    }  )*  {    return l;  }}IRValue unary() :{  IRValue r1;  BType tp = null;  Token tn = null, nnt = null, ts = null;}{  (    LOOKAHEAD(< LPARAM > (< NOTNULL >)? ids() < RPARAM >)    < LPARAM > (nnt = < NOTNULL >)? tp = typeDef()    {      tp.setNotNull(nnt != null);    }    < RPARAM >  )?  (    tn = < NOT >  | ts = < SUB >  )?  r1 = literal()  (    LOOKAHEAD(< DOT > < ID > < LPARAM >)    r1 = ridsDef(r1)  )*  {    if (tn != null) r1 = new Not(r1, tn);    if (ts != null) r1 = new Mul(r1, new RNumber(TokenUtil.newInstance("-1")), tn);  }  {    if (tp != null)    {      return new Cast(tp, r1);    }    else    {      return r1;    }  }}IRValue literal() :{  IRValue r1;  Token tt = null;}{  (    < LPARAM > r1 = rvalue() < RPARAM >  | t = < NULL >    {      r1 = new RNull(t);    }  | t = < CONSTANT >    {      r1 = new RNumber(t);    }  | t = < STRING >    {      r1 = new RString(t);    }  | t = < BOOLEAN >    {      r1 = new RBoolean(t);    }  | r1 = newDef()  | LOOKAHEAD(lvalue() (< SUM >  | < SUB >  | < MUL >  | < DIV >)? < EQUAL > rvalue())    r1 = assignRDef()  | r1 = rthisDef()  | r1 = rsuperDef()  | r1 = ridDef()  )  {    return r1;  }}IRValue rthisDef() :{  IRValue r1;  Token t;}{  t = < THIS >  {    r1 = new RThis(t);  }  (    LOOKAHEAD(< DOT > < ID >, { getToken(3).kind != LPARAM })    < DOT > t = < ID >    {      r1 = new RGetField(r1, t);    }  )?  {    return r1;  }}IRValue rsuperDef() :{  Token t;}{  t = < SUPER >  {    return new RSuper(t);  }}IRValue ridDef() :{  IRValue r1;}{  t = < ID >  {    r1 = new RIdentify(t);  }  (    LOOKAHEAD(< DOT > < ID >, { getToken(3).kind != LPARAM })    < DOT > t = < ID >    {      r1 = new RGetField(r1, t);    }  )?  {    return r1;  }}IRValue ridsDef(IRValue r2) :{  IRValue r1;}{  < DOT > t = < ID >  {    r1 = new Call(r2, t);  }  < LPARAM >  (    rvalues    (      (        (Call) r1      )      .getParams()    )  )?  < RPARAM >  (    < LARRAY > t = < NATURAL > < RARRAY >    {      r1 = new Array(r1, new RNumber(t));    }  )?  {    return r1;  }}IRValue newDef() :{  New c = new New();  Token t;  BType tp;}{  < NEW > tp = typeDef()  {    c.setType(tp);  }  < LPARAM >  (    rvalues    (      c.getParams()    )  )?  < RPARAM >  {    return c;  }}Token id() :{  Token t;}{  t = < ID >  {    return t;  }}Token ids() :{  Token t;}{  t = < ID >  {    tokens.add(t);  }  (    t = < DOT >    {      tokens.add(t);    }    t = < ID >    {      tokens.add(t);    }  )*  {    Token result = BTokenUtil.join(tokens);    tokens.clear();    return result;  }}Token importDef() :{  Token t;}{  < IMPORT > t = < ID >  {    tokens.add(t);  }  (    t = < DOT >    {      tokens.add(t);    }    (      t = < ID >      {        tokens.add(t);      }    | t = < MUL >      {        tokens.add(t);      }      < SEMICOMMA >      {        Token result = BTokenUtil.join(tokens);        tokens.clear();        return result;      }    )  )*  < SEMICOMMA >  {    Token result = BTokenUtil.join(tokens);    tokens.clear();    return result;  }}BAccess access() :{}{  (    < PUBLIC >    {      return BAccess.PUBLIC;    }  | < PROTECTED >    {      return BAccess.PROTECTED;    }  | < PRIVATE >    {      return BAccess.PRIVATE;    }  )}