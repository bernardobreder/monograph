	options{  JDK_VERSION = "1.5";  static = false;}PARSER_BEGIN(Grammar)package breder.processor.parser;import breder.processor.node.*;public class Grammar{  BProcessor p = new BProcessor();}PARSER_END(Grammar)SKIP :{  " "| "\r"| "\t"| "\n"}SPECIAL_TOKEN :{  < SINGLE_LINE_COMMENT :    "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    )? >}MORE :{  < "/**" ~[ "/" ] >  {    input_stream.backup(1);  }  : IN_JAVA_DOC_COMMENT| < "/*" > : IN_MULTI_LINE_COMMENT}< IN_JAVA_DOC_COMMENT >SPECIAL_TOKEN :{  < JAVA_DOC_COMMENT : "*/" > : DEFAULT}< IN_MULTI_LINE_COMMENT >SPECIAL_TOKEN :{  < MULTI_LINE_COMMENT : "*/" > : DEFAULT}< IN_JAVA_DOC_COMMENT, IN_MULTI_LINE_COMMENT >MORE :{  < ~[ ] >}TOKEN : /* OPERATORS */{  < SUM : "+" >| < SUB : "-" >| < MUL : "*" >| < DIV : "/" >| < EQUAL : "=" >| < SEMICOMMA : ";" >| < PRAGMA : "#" >| < DOT : "." >| < COMMA : "," >| < DOTDOT : ":" >| < LPARAM : "(" >| < RPARAM : ")" >| < LBLOCK : "{" >| < RBLOCK : "}" >| < LARRAY : "[" >| < RARRAY : "]" >| < LOW : "<" >| < HIGH : ">" >| < NOT : "!" >| < DEFINE : "define" >| < WHILE : "while" >| < IF : "if" >| < ELSE : "else" >| < OR : "or" >| < AND : "and" >}TOKEN :{  < CONSTANT :    (< ZDIGIT >)+    (      < DOT > (< ZDIGIT >)+    )? >| < NATURAL : (< ZDIGIT >)+ >| < ID :    < LETTER >    (      < LETTER >    | < ZDIGIT >    )* >| < #DIGIT : [ "1"-"9" ] >| < #ZDIGIT : [ "0"-"9" ] >| < #LETTER :    [ "a"-"z" ]  | [ "A"-"Z" ]  | "_" >}BProcessor init() :{}{  (    pragmaDef()  | callDef() < SEMICOMMA >  | declareDef()  )*  < EOF >  {    return p;  }}void pragmaDef() :{}{  < PRAGMA >  (    defineDef()  )}void defineDef() :{}{  < DEFINE > < ID > exprDef()}void declareDef() :{}{  < SUB > < ID > < LPARAM >  (    < ID > < DOTDOT > < CONSTANT > (< COMMA > < ID > < DOTDOT > < CONSTANT >)*  )?  < RPARAM >  (    < SEMICOMMA >  | < LBLOCK >    (      cmdDef()    )*    < RBLOCK >  )}void cmdDef() :{}{  < LBLOCK > cmdDef() < RBLOCK >| LOOKAHEAD(lvalueDef() < EQUAL >)  assignDef() < SEMICOMMA >| whileDef()| ifDef()| exprDef() < SEMICOMMA >}void assignDef() :{}{  lvalueDef() < EQUAL > rvalueDef()}void whileDef() :{}{  < WHILE > < LPARAM > rvalueDef() < RPARAM > < LBLOCK >  (    cmdDef()  )*  < RBLOCK >}void ifDef() :{}{  < IF > < LPARAM > rvalueDef() < RPARAM > < LBLOCK >  (    cmdDef()  )*  < RBLOCK >  (    < ELSE > cmdDef()  )?}BLValue lvalueDef() :{  Token t;  BRValue v;}{  (    LOOKAHEAD(< ID > < LARRAY >)    t = < ID >    (      < LARRAY > v = rvalueDef() < RARRAY >    )    {      return new BLMemoryIdentify(t, v);    }  | t = < ID >    {      return new BLIdentify(t);    }  )}BRValue rvalueDef() :{  BRValue v;}{  v = exprDef()  {    return v;  }}BRValue exprDef() :{  BRValue v;}{  v = orDef()  {    return v;  }}BRValue orDef() :{  BRValue v;}{  v = equalDef()  (    LOOKAHEAD(< OR >)    < OR > equalDef()  | LOOKAHEAD(< AND >)    < AND > equalDef()  )*  {    return v;  }}BRValue equalDef() :{  BRValue v;}{  v = sumDef()  (    LOOKAHEAD(< EQUAL > < EQUAL >)    < EQUAL > < EQUAL > sumDef()  | LOOKAHEAD(< NOT > < EQUAL >)    < NOT > < EQUAL > sumDef()  | LOOKAHEAD(< LOW > < EQUAL >)    < LOW > < EQUAL > sumDef()  | LOOKAHEAD(< HIGH > < EQUAL >)    < HIGH > < EQUAL > sumDef()  | LOOKAHEAD(< LOW >)    < LOW > sumDef()  | LOOKAHEAD(< HIGH >)    < HIGH > sumDef()  )*  {    return v;  }}BRValue sumDef() :{  BRValue v;}{  v = mulDef()  (    LOOKAHEAD(< SUM >)    < SUM > mulDef()  | LOOKAHEAD(< SUB >)    < SUB > mulDef()  )*  {    return v;  }}BRValue mulDef() :{  BRValue v;}{  v = unaryDef()  (    LOOKAHEAD(< MUL >)    < MUL > unaryDef()  | LOOKAHEAD(< DIV >)    < DIV > unaryDef()  )*  {    return v;  }}BRValue unaryDef() :{  Token t = null;  BRValue v;}{  (t = < SUB >)? v = literalDef()  {    if (t != null)    {      return v;    }    else    {      return v;    }  }}BRValue literalDef() :{  Token t;  BRValue v;}{  LOOKAHEAD(< ID > < LPARAM >)  v = callDef()  {    return v;  }| v = idDef()  {    return v;  }| t = < CONSTANT >  {    return new BNumber(t);  }}BRValue idDef() :{  Token t = null;  BRValue v;}{  (    LOOKAHEAD(< ID > < LARRAY >)    t = < ID >    (      < LARRAY > v = rvalueDef() < RARRAY >    )    {      return new BMemoryIdentify(t, v);    }  | t = < ID >    {      return new BIdentify(t);    }  )}BRValue callDef() :{  Token t;}{  t = < ID > < LPARAM >  (    exprDef()    (      < COMMA > exprDef()    )*  )?  < RPARAM >  {    return new BCall(t);  }}